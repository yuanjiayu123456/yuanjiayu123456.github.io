# -*- coding: utf-8 -*-
"""
STEP 4 (Revised): IQ è§£è°ƒä¸èƒ½é‡æå–ä»¿çœŸ (Dynamic & Bit-Exact)
åŠŸèƒ½ï¼š
1. [æ–°å¢] åŠ¨æ€è®¡ç®— LPF ç³»æ•° (åŸºäºæˆªæ­¢é¢‘ç‡)ã€‚
2. [ä¿®æ­£] LPF ç¡¬ä»¶æ¨¡å‹ä¸¥æ ¼å¯¹é½å›¾ç‰‡ä½å®½ (a_coef ä¸º Q1.14)ã€‚
3. [ä¿®æ­£] NCO é€»è¾‘ä¸¥æ ¼å¯¹é½å›¾ç‰‡ (Offset + Threshold)ã€‚
4. è¾“å‡º (0,20,20) æ ¼å¼èƒ½é‡åŒ…ç»œã€‚
"""

import numpy as np
import scipy.signal as signal
import matplotlib.pyplot as plt
import os

# ================= é…ç½®åŒºåŸŸ =================
CONFIG = {
    'fs': 500000.0,         # è¾“å…¥é‡‡æ ·ç‡ (BPDF è¾“å‡º)
    
    # --- NCO é…ç½® ---
    'nco_fc_val': 4,        # é¢‘ç‡æ§åˆ¶å­— (4/16 * 500k = 125k)
    
    # --- LPF é…ç½® (åŠ¨æ€ç”Ÿæˆ) ---
    'lpf_cutoff': 10000.0,  # ä½é€šæˆªæ­¢é¢‘ç‡ 10kHz (å¯è°ƒ!)
    
    # --- æŠ½å–é…ç½® ---
    'decimation': 16,       # æŠ½å–å€æ•°
    
    # --- æ–‡ä»¶è·¯å¾„ ---
    'in_file': 'data/data_iir_out.dat',
    'out_file': 'data/data_iq_out.dat',
    'plot_file': 'output/step4_iq_demod_result.png'
}
# ===========================================

def float_to_fixed(val, total_bits, frac_bits, signed=True):
    """é€šç”¨å®šç‚¹è½¬æ¢å‡½æ•°"""
    scaling = 1 << frac_bits
    if signed:
        max_val = (1 << (total_bits - 1)) - 1
        min_val = -(1 << (total_bits - 1))
    else:
        max_val = (1 << total_bits) - 1
        min_val = 0
    int_val = int(round(val * scaling))
    return max(min(int_val, max_val), min_val)

def design_iq_lpf_coeffs(cutoff, fs):
    """
    æ ¹æ®æˆªæ­¢é¢‘ç‡åŠ¨æ€ç”Ÿæˆ LPF ç³»æ•°
    ç¡¬ä»¶ç»“æ„ä¸º All-Pole (å…¨æç‚¹) ç»“æ„: y[n] = g*x[n] - a0*y[n-1] - a1*y[n-2]
    """
    # 1. ä½¿ç”¨ Scipy è®¾è®¡æ ‡å‡† 2é˜¶ Butterworth
    # output='ba' è¿”å›åˆ†å­åˆ†æ¯ç³»æ•°
    b, a = signal.butter(2, cutoff, fs=fs, btype='lowpass')
    
    # 2. æå–åˆ†æ¯ç³»æ•° (Feedback)
    # scipy a = [1, a1, a2], å¯¹åº”æ–¹ç¨‹ y[n] = x - a1*y[n-1] - a2*y[n-2]
    # ç¡¬ä»¶é€šå¸¸ä½¿ç”¨å‡æ³•å™¨ï¼Œæ‰€ä»¥ç³»æ•°ç›´æ¥å– a[1] å’Œ a[2] çš„æ­£å€¼å³å¯(åœ¨ä»£ç é‡Œåšå‡æ³•)
    # æˆ–è€…å–è´Ÿå€¼åœ¨ä»£ç é‡ŒåšåŠ æ³•ã€‚
    # è§‚å¯Ÿå›¾ç‰‡ï¼šAdder å¤„æœ‰ '-' å·ï¼Œè¯´æ˜ç¡¬ä»¶åšå‡æ³•ã€‚
    # æ‰€ä»¥æˆ‘ä»¬ä¼ å…¥æ­£çš„ a[1], a[2]
    a0_val = a[1]
    a1_val = a[2]
    
    # 3. è®¡ç®—å¢ç›Š g
    # ä¸ºäº†ä¿è¯ DC (0Hz) å¤„çš„å¢ç›Šä¸º 1 (0dB)
    # H(z=1) = g / (1 + a1 + a2) = 1  =>  g = 1 + a1 + a2
    g_val = 1.0 + a0_val + a1_val
    
    return g_val, a0_val, a1_val

class NCO_Hardware_Model:
    """
    ä¸¥æ ¼å¯¹é½ IMG20260127193719.jpg
    Input: Fc_cfg (0,4,0)
    Internal: 4-bit Accumulator
    Output: +1/-1
    """
    def __init__(self, fc_cfg):
        self.acc = 0
        self.fc_cfg = int(fc_cfg)
        self.nbits = 4
        self.mod_mask = (1 << self.nbits) - 1
        # é˜ˆå€¼é€šå¸¸ä¸ºé‡ç¨‹çš„ä¸€åŠ (8)
        self.th = 1 << (self.nbits - 1) 

    def step(self):
        # 1. ç´¯åŠ 
        self.acc = (self.acc + self.fc_cfg) & self.mod_mask
        
        # 2. Iè·¯ç”Ÿæˆ (å›¾ç¤º: + 1<<(N-2) å³ +4)
        offset_i = 1 << (self.nbits - 2)
        idx_i = (self.acc + offset_i) & self.mod_mask
        lo_i = 1 if idx_i >= self.th else -1
        
        # 3. Qè·¯ç”Ÿæˆ (å›¾ç¤º: + 1<<(N-1) å³ +8)
        offset_q = 1 << (self.nbits - 1)
        idx_q = (self.acc + offset_q) & self.mod_mask
        lo_q = 1 if idx_q >= self.th else -1
        
        return lo_i, lo_q

class LPF_Hardware_Model:
    """
    ä¸¥æ ¼å¯¹é½ IMG20260127193456.jpg
    Input: (1,20,19)
    Coeffs: G(0,20,20), A(1,16,14)  <-- æ³¨æ„è¿™é‡Œ A æ˜¯ 14ä½å°æ•°
    Internal: (1,24,23)
    """
    def __init__(self, g, a0, a1):
        # é‡åŒ–ç³»æ•°
        self.g = float_to_fixed(g, 20, 20, signed=False)  # Q0.20
        self.a0 = float_to_fixed(a0, 16, 14, signed=True) # Q1.14
        self.a1 = float_to_fixed(a1, 16, 14, signed=True) # Q1.14
        
        print(f"ğŸ”§ LPF Coeffs (Hardware): G=0x{self.g:X}, A0=0x{self.a0 & 0xFFFF:X}, A1=0x{self.a1 & 0xFFFF:X}")
        
        # çŠ¶æ€å¯„å­˜å™¨ (1,24,23)
        self.z1 = 0
        self.z2 = 0

    def process(self, x_int):
        # x_int (Q1.19)
        
        # 1. å‰å‘è·¯å¾„: G(Q0.20) * X(Q1.19) = Q1.39
        # å¯¹é½åˆ° Q1.23 => å³ç§» 16ä½ (39-23=16)
        term_g = (x_int * self.g) >> 16
        
        # 2. åé¦ˆè·¯å¾„: A(Q1.14) * Z(Q1.23) = Q2.37
        # å¯¹é½åˆ° Q1.23 => å³ç§» 14ä½ (37-23=14)
        term_a0 = (self.a0 * self.z1) >> 14
        term_a1 = (self.a1 * self.z2) >> 14
        
        # 3. ç´¯åŠ  (å›¾ç¤ºä¸ºå‡æ³•: + - -)
        acc = term_g - term_a0 - term_a1
        
        # 4. é¥±å’Œå¤„ç† (Saturation to 24 bits)
        sat_max = (1 << 23) - 1
        sat_min = -(1 << 23)
        acc = max(min(acc, sat_max), sat_min)
        
        # 5. æ›´æ–°çŠ¶æ€
        self.z2 = self.z1
        self.z1 = acc
        
        return acc

def main():
    if not os.path.exists('data'): os.makedirs('data')
    if not os.path.exists('output'): os.makedirs('output')

    # 1. è¯»å– BPDF è¾“å‡º
    if not os.path.exists(CONFIG['in_file']):
        print(f"âŒ æ‰¾ä¸åˆ°è¾“å…¥æ–‡ä»¶ {CONFIG['in_file']}ï¼Œè¯·å…ˆè¿è¡Œ Step 3 BPDFã€‚")
        return
    bpdf_data_float = np.loadtxt(CONFIG['in_file'])
    # è½¬å›ç¡¬ä»¶å®šç‚¹ (Q1.19)
    bpdf_data_int = (bpdf_data_float * (1 << 19)).astype(np.int64)

    # 2. [åŠ¨æ€è®¡ç®—ç³»æ•°]
    print(f"ğŸ“ è®¾è®¡ LPF ç³»æ•°: Cutoff={CONFIG['lpf_cutoff']}Hz, Fs={CONFIG['fs']}Hz")
    g_val, a0_val, a1_val = design_iq_lpf_coeffs(CONFIG['lpf_cutoff'], CONFIG['fs'])
    print(f"   Float Coeffs: G={g_val:.4f}, A0={a0_val:.4f}, A1={a1_val:.4f}")

    # 3. åˆå§‹åŒ–ç¡¬ä»¶æ¨¡å‹
    nco = NCO_Hardware_Model(CONFIG['nco_fc_val'])
    lpf_i = LPF_Hardware_Model(g_val, a0_val, a1_val)
    lpf_q = LPF_Hardware_Model(g_val, a0_val, a1_val) # ä¸¤è·¯ç³»æ•°ç›¸åŒ

    iq_output_float = []
    
    print("âš™ï¸ è¿è¡Œ IQ ç¡¬ä»¶ä»¿çœŸ (Mixer -> LPF -> Decim -> Energy)...")
    
    # 4. é€ç‚¹å¤„ç†
    for idx, x_in in enumerate(bpdf_data_int):
        # --- A. NCO & Mixer ---
        lo_i, lo_q = nco.step()
        
        # æ— ä¹˜æ³•æ··é¢‘ (Sign Flip)
        mix_i = x_in if lo_i == 1 else -x_in
        mix_q = x_in if lo_q == 1 else -x_in
        
        # --- B. LPF ---
        y_i = lpf_i.process(mix_i)
        y_q = lpf_q.process(mix_q)
        
        # --- C. Decimation (16) & Energy ---
        if idx % CONFIG['decimation'] == 0:
            # y_i, y_q (Q1.23)
            
            # Square: Q1.23 * Q1.23 = Q2.46
            # æˆ‘ä»¬éœ€è¦ Q0.24 (Unsigned) ä½œä¸ºä¸­é—´ç»“æœ
            # Q2.46 >> 22 = Q0.24
            sq_i = (y_i * y_i) >> 22
            sq_q = (y_q * y_q) >> 22
            
            energy = sq_i + sq_q
            
            # Saturation [0, 2^24-1]
            sat_val = (1 << 24) - 1
            energy = min(max(energy, 0), sat_val)
                
            # Extra Bits [5, 24] -> Extract top 20 bits
            # (24 downto 5)
            data_out_int = (energy >> 5) & 0xFFFFF
            
            # è½¬æµ®ç‚¹ (Q0.20)
            iq_output_float.append(data_out_int / (1 << 20))

    # 5. ä¿å­˜ä¸ç»˜å›¾
    iq_arr = np.array(iq_output_float)
    np.savetxt(CONFIG['out_file'], iq_arr, fmt='%.8f')
    
    plt.style.use('seaborn-v0_8-paper')
    plt.figure(figsize=(10, 5), dpi=150)
    
    t = np.arange(len(iq_arr)) / (CONFIG['fs'] / CONFIG['decimation']) * 1000 # ms
    plt.plot(t, iq_arr, color='#ff7f0e', lw=1.5, label='Energy Envelope')
    
    plt.title(f"IQ Output (Cutoff={CONFIG['lpf_cutoff']}Hz)\nFormat: (0,20,20)", fontweight='bold')
    plt.xlabel('Time (ms)')
    plt.ylabel('Amplitude')
    plt.grid(True, alpha=0.3)
    plt.legend()
    plt.tight_layout()
    plt.savefig(CONFIG['plot_file'])
    print(f"âœ… å®Œæˆã€‚ç»“æœå·²ä¿å­˜: {CONFIG['plot_file']}")

if __name__ == "__main__":
    main()
