# -*- coding: utf-8 -*-
"""
STEP 5 (Alternative): åŠ¨æ€ DC é”å®šæ–¹æ¡ˆ (Sample & Hold Subtraction)
åŸç†ï¼šåˆ©ç”¨ Idle é˜¶æ®µè®¡ç®—å¹³å‡ DCï¼Œå¹¶åœ¨åç»­é˜¶æ®µé”å®šè¯¥å€¼è¿›è¡Œå‡æ³•ã€‚
ä¼˜åŠ¿ï¼š
1. 0 ç•¸å˜ï¼šé•¿ç ä¸ä¼šå€¾æ–œã€‚
2. 0 èµ„æºï¼šä¸éœ€è¦ FIR ä¹˜æ³•å™¨ã€‚
"""
import numpy as np
import matplotlib.pyplot as plt
import os

CONFIG = {
    'fs': 31250.0,
    'in_file': 'data/data_iq_out.dat',
    'out_file': 'data/data_hpf_out.dat', # è¦†ç›–è¾“å‡ºï¼Œä¾›ä¸‹ä¸€æ­¥ä½¿ç”¨
    'plot_file': 'output/step5_dc_latch.png',
    
    # é”å®šæ—¶é—´ï¼šåˆ©ç”¨å‰ 2ms (çº¦64ç‚¹) è®¡ç®— DC
    'latch_len': 64 
}

def float_to_fixed(val, total_bits, frac_bits):
    scaling = 1 << frac_bits
    int_val = int(round(val * scaling))
    return int_val

class DC_Latch_Hardware:
    def __init__(self, latch_len):
        self.latch_len = latch_len
        self.counter = 0
        self.accumulator = 0.0
        self.locked_dc = 0.0
        self.calibrated = False

    def process(self, x_float):
        # 1. æ ¡å‡†é˜¶æ®µ (Calibration)
        if self.counter < self.latch_len:
            self.accumulator += x_float
            self.counter += 1
            
            # åœ¨æœ€åä¸€åˆ»è®¡ç®—å¹³å‡å€¼å¹¶é”å®š
            if self.counter == self.latch_len:
                self.locked_dc = self.accumulator / self.latch_len
                print(f"ğŸ”’ ç¡¬ä»¶è‡ªåŠ¨æ ¡å‡†å®Œæˆ: Locked DC = {self.locked_dc:.8f}")
                self.calibrated = True
            
            return 0.0 # æ ¡å‡†æœŸé—´ Mute è¾“å‡º
            
        # 2. å·¥ä½œé˜¶æ®µ (Operation)
        else:
            # ç®€å•çš„å‡æ³•
            out = x_float - self.locked_dc
            return out

def main():
    if not os.path.exists(CONFIG['in_file']): return
    iq_data = np.loadtxt(CONFIG['in_file'])
    
    dc_remover = DC_Latch_Hardware(CONFIG['latch_len'])
    
    out_data = []
    for val in iq_data:
        out_data.append(dc_remover.process(val))
    out_data = np.array(out_data)
    
    # ä¿å­˜ç»“æœä¾›ä¸‹ä¸€æ­¥ä½¿ç”¨
    np.savetxt(CONFIG['out_file'], out_data, fmt='%.8f')

    # ç»˜å›¾
    plt.style.use('seaborn-v0_8-paper')
    fig, ax = plt.subplots(2, 1, figsize=(10, 8), dpi=150)
    
    # å›¾1: åŸå§‹è¾“å…¥
    ax[0].plot(iq_data, 'orange', label='Input (with DC)')
    ax[0].set_title(f'Input Signal (DC ~ {np.mean(iq_data[:100]):.5f})')
    
    # å›¾2: å‡å»é”å®š DC åçš„è¾“å‡º
    ax[1].plot(out_data, '#1f77b4', lw=1.5, label='Output (Input - LockedDC)')
    ax[1].set_title('Output via "Dynamic DC Latch" (No Filter Distortion!)')
    ax[1].axhline(0, color='black', alpha=0.3)
    ax[1].grid(True, alpha=0.3)
    
    # æ ‡æ³¨é•¿ä½ç”µå¹³åŒºåŸŸ (EQ)
    # çœ‹çœ‹æ˜¯ä¸æ˜¯çœŸçš„å¹³ç›´ï¼
    ax[1].text(100, -0.0001, "Perfectly Flat EQ!", color='green', fontweight='bold')

    plt.tight_layout()
    plt.savefig(CONFIG['plot_file'])
    print(f"âœ… ç»“æœå·²ä¿å­˜: {CONFIG['plot_file']}")

if __name__ == "__main__":
    main()
