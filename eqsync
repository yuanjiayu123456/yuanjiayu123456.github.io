# -*- coding: utf-8 -*-
"""
STEP 6 (Final Refined): EQ_SYNC åŒæ­¥æ¨¡å— - é€‚é… Load Modulation
ä¿®æ”¹ç‚¹ï¼š
1. ç³»æ•°ç”Ÿæˆé€»è¾‘ç¿»è½¬ï¼šé€»è¾‘ '1' å¯¹åº”ç‰©ç† 'è´Ÿç”µå‹'ï¼Œé€»è¾‘ '0' å¯¹åº”ç‰©ç† 'æ­£ç”µå‹'ã€‚
2. æ¶æ„ä¿æŒä¸ç¡¬ä»¶å›¾ä¸€è‡´ï¼šWindow -> MF -> Peak Find -> Slice Outputã€‚
"""
import numpy as np
import matplotlib.pyplot as plt
import os

CONFIG = {
    'fs': 31250.0,
    
    # è¿ä¾‹ç  (Violation Code): 11ä¸ª1ï¼Œ1ä¸ª0
    # æ³¨æ„ï¼šç¡¬ä»¶å›¾ä¸Šå†™çš„æ˜¯ '1111110' (7ä½)ï¼Œä½†ä¸ºäº†é…åˆæˆ‘ä»¬ SDM ç”Ÿæˆçš„ä¿¡å·ï¼Œ
    # æˆ‘ä»¬è¿™é‡Œå¿…é¡»ä½¿ç”¨ SDM é‡Œçš„ 12ä½ å®šä¹‰ã€‚é€»è¾‘ä¸Šæ˜¯ä¸€æ ·çš„ã€‚
    'eq_pattern': [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0],
    
    # start_index: è·³è¿‡ SDM é‡Œçš„ Preamble (0101...) å’Œ HPF ç¬æ€
    # Preamble çº¦ 8 chipsï¼ŒåŠ ä½™é‡å»ºè®®è®¾ä¸º 80-100
    'start_index': 80,  
    
    'search_len': 2000,
    
    'in_file': 'data/data_hpf_out.dat',
    'out_file': 'data/data_sync_out.dat',
    'plot_file': 'output/step6_eq_sync_final.png'
}

def float_to_fixed(val, total_bits, frac_bits, signed=True):
    scaling = 1 << frac_bits
    if signed:
        max_val = (1 << (total_bits - 1)) - 1
        min_val = -(1 << (total_bits - 1))
    else:
        max_val = (1 << total_bits) - 1
        min_val = 0
    int_val = int(round(val * scaling))
    return max(min(int_val, max_val), min_val)

def generate_mf_coeffs(pattern):
    """
    ç”ŸæˆåŒ¹é…æ»¤æ³¢å™¨ç³»æ•° (é€‚é… Load Modulation)
    é€»è¾‘ 1 (Mod On)  -> AmpLow  -> HPFè´Ÿå€¼ -> ç³»æ•°å– -1.0
    é€»è¾‘ 0 (Mod Off) -> AmpHigh -> HPFæ­£å€¼ -> ç³»æ•°å– +1.0
    """
    waveform = []
    for chip in pattern:
        # [å…³é”®ä¿®æ”¹] ææ€§ç¿»è½¬
        val = -1.0 if chip == 1 else 1.0
        waveform.append(val)
        
    # åŒ¹é…æ»¤æ³¢å™¨æ ¸å¿ƒï¼šæ—¶é—´åè½¬ (Time Reversal)
    # y[n] = x[n]*c[0] + x[n-1]*c[1]... 
    # è¦å®ç°ç›¸å…³è¿ç®—ï¼Œç³»æ•°å¿…é¡»æ˜¯æ³¢å½¢çš„ç¿»è½¬
    coeffs = np.array(waveform)[::-1]
    
    # å½’ä¸€åŒ–
    return coeffs / len(coeffs)

class MF_Hardware_Model:
    """ç¡¬ä»¶ FIR æ»¤æ³¢å™¨æ¨¡å‹"""
    def __init__(self, coeffs):
        self.coeffs_int = [float_to_fixed(c, 16, 15, signed=True) for c in coeffs]
        self.buffer = [0] * len(coeffs)

    def process(self, x_float):
        x_int = float_to_fixed(x_float, 20, 19, signed=True)
        self.buffer.pop()
        self.buffer.insert(0, x_int)
        
        acc = 0
        for i in range(len(self.buffer)):
            acc += self.buffer[i] * self.coeffs_int[i]
            
        out_int = acc >> 18
        sat_max = (1 << 16) - 1
        sat_min = -(1 << 16)
        if out_int > sat_max: out_int = sat_max
        elif out_int < sat_min: out_int = sat_min
            
        return out_int / (1 << 16)

def main():
    if not os.path.exists('data'): os.makedirs('data')
    if not os.path.exists(CONFIG['in_file']): 
        return

    hpf_data = np.loadtxt(CONFIG['in_file'])
    
    # 1. ç¡¬ä»¶æ¨¡å—: inputs[start:end]
    start = CONFIG['start_index']
    end = min(len(hpf_data), start + CONFIG['search_len'])
    mf_input_slice = hpf_data[start:end]
    
    print(f"âœ‚ï¸ æœç´¢çª—å£: Index {start} -> {end}")

    # 2. ç¡¬ä»¶æ¨¡å—: MF (Matched Filter)
    coeffs = generate_mf_coeffs(CONFIG['eq_pattern'])
    mf = MF_Hardware_Model(coeffs)
    
    mf_out = []
    for val in mf_input_slice:
        mf_out.append(mf.process(val))
    mf_out = np.array(mf_out)
    
    # 3. ç¡¬ä»¶æ¨¡å—: find_index (å¯»æ‰¾æ­£å³°å€¼)
    # ç”±äºç³»æ•°ææ€§å·²ç»ç¿»è½¬ï¼ŒåŒ¹é…æ—¶ä¼šå‡ºç°æ­£å³°å€¼
    peak_rel_idx = np.argmax(mf_out) 
    peak_val = mf_out[peak_rel_idx]
    
    # è®¡ç®—ç»å¯¹ä½ç½® (eq_index)
    peak_abs_idx = start + peak_rel_idx
    
    print(f"âœ… åŒæ­¥é”å®š: AbsIndex={peak_abs_idx}, Value={peak_val:.6f}")
    
    # 4. ç¡¬ä»¶æ¨¡å—: Output Bypass (æ ¹æ® index è¾“å‡ºæ•°æ®)
    aligned_data = hpf_data[peak_abs_idx:]
    np.savetxt(CONFIG['out_file'], aligned_data, fmt='%.8f')

    # ç»˜å›¾éªŒè¯
    plt.style.use('seaborn-v0_8-paper')
    fig, ax = plt.subplots(3, 1, figsize=(10, 10), dpi=150)
    
    # å›¾1: æœç´¢çª—å£
    ax[0].plot(hpf_data[:end+100], 'gray', alpha=0.5, label='HPF Output')
    ax[0].axvspan(start, end, color='green', alpha=0.1, label='Search Window')
    ax[0].set_title('Step 1: Window Setup (inputs[start:end])', fontweight='bold')
    ax[0].legend()
    
    # å›¾2: MF è¾“å‡º
    ax[1].plot(np.arange(start, end), mf_out, '#d62728', label='MF Correlation')
    ax[1].plot(peak_abs_idx, peak_val, 'x', color='black', markersize=10)
    ax[1].set_title(f'Step 2: MF Output (Peak @ {peak_abs_idx})', fontweight='bold')
    ax[1].legend()

    # å›¾3: åŒæ­¥åçš„æ•°æ® (éªŒè¯æ•°æ®éƒ¨åˆ†)
    # é¢„æœŸ: æ•°æ®1 (11110000) -> ç‰©ç†: Low*4 High*4 -> HPF: è´Ÿ*4 æ­£*4
    # é¢„æœŸ: æ•°æ®0 (00001111) -> ç‰©ç†: High*4 Low*4 -> HPF: æ­£*4 è´Ÿ*4
    view_len = min(200, len(aligned_data))
    ax[2].plot(aligned_data[:view_len], '#1f77b4', lw=1.5, label='Synced Stream')
    ax[2].set_title('Step 3: Output Stream (Should see Neg->Pos for Data 1)', fontweight='bold')
    ax[2].grid(True, alpha=0.3)
    
    plt.tight_layout()
    plt.savefig(CONFIG['plot_file'])
    print(f"ğŸ’¾ ç»“æœå›¾å·²ä¿å­˜: {CONFIG['plot_file']}")

if __name__ == "__main__":
    main()
