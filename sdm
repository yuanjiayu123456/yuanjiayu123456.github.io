# -*- coding: utf-8 -*-
"""
STEP 1 (Final Refined): SDM ä¿¡å·æº - ä¿®æ­£è°ƒåˆ¶é€»è¾‘ç‰ˆ
æ”¹åŠ¨ç‚¹ï¼š
1. ä»…ä¿®æ”¹ generate_custom_protocol å‡½æ•°ã€‚
2. å®ç° Load Modulation é€»è¾‘ (1=Low, 0=High)ã€‚
3. åŠ å…¥ Preamble (0101...) å”¤é†’ HPFã€‚
"""

import numpy as np
import matplotlib.pyplot as plt
from scipy import signal
import os

# æ£€æŸ¥ç›®å½•
if not os.path.exists('data'): os.makedirs('data')
if not os.path.exists('output'): os.makedirs('output')

# ================= é…ç½®åŒºåŸŸ =================
CONFIG = {
    'fs': 16e6,              # é‡‡æ ·ç‡ 16MHz
    'duration': 0.08,        # ä»¿çœŸæ—¶é•¿ 80ms
    'carrier_freq': 125000,  # è½½æ³¢ 125kHz
    
    # è°ƒåˆ¶æ·±åº¦é…ç½®
    # å»ºè®®å…ˆç”¨ 1/2000 è·‘é€šï¼Œä¹‹åå†æ”¹ 1/50000
    'mod_depth': 1/2000,     
    'base_amp': 0.5,         # è½½æ³¢åŸºå‡†å¹…åº¦ (500V -> 0.5å½’ä¸€åŒ–)
    
    'chip_period': 32e-6,    # 1 Chip = 32us
    
    'snr_db': 140,           # æ³¨å…¥å™ªå£°ä¿¡å™ªæ¯”
    
    # åˆ†æå‚æ•°
    'view_bw': [0, 250000],
    'signal_bw': [120000, 130000],
    'total_bw': [110000, 140000],
    
    'out_pdm': 'data/data_pdm.dat',
    'out_ref': 'data/data_ref.dat',
    'plot_file': 'output/sdm_analysis.png'
}

ORIGINAL_G_RES = [0.0078, 0.0117, 0.0259]

class CTSDM_Model:
    """è¿ç»­æ—¶é—´ Sigma-Delta è°ƒåˆ¶å™¨æ¨¡å‹"""
    def __init__(self, fs=16e6, osr=10, g_res_scale=1.0):
        self.fs = fs
        self.ts = 1/fs
        self.sub_steps = osr  
        self.dt = self.ts / self.sub_steps
        self.k_int = 8e6 
        self.g_in, self.g_dac = 0.1339, 0.1337
        
        # ç¼©æ”¾ g_res ä»¥ç§»åŠ¨é™·æ³¢ç‚¹åˆ° 125kHz
        self.g_res1 = ORIGINAL_G_RES[0] * g_res_scale
        self.g_res2 = ORIGINAL_G_RES[1] * g_res_scale
        self.g_res3 = ORIGINAL_G_RES[2] * g_res_scale
        
        self.a = [0.2713, 0.2345, 0.1981, 0.1303, 0.0903]
        self.c = [5.1539, 6.6828, 6.7732, 5.2973, 4.2352, 1.7112]
        self.g_eld = 0.3686
        self.reset()

    def reset(self):
        self.x = np.zeros(6)
        self.delay_reg = -1.0 

    def step(self, u_current):
        v_applied = self.delay_reg
        for _ in range(self.sub_steps):
            x = self.x
            dx0 = self.k_int * (u_current * self.g_in - v_applied * self.g_dac - x[1] * self.g_res1)
            dx1 = self.k_int * (x[0] * self.a[0])
            dx2 = self.k_int * (x[1] * self.a[1] - x[3] * self.g_res2)
            dx3 = self.k_int * (x[2] * self.a[2])
            dx4 = self.k_int * (x[3] * self.a[3] - x[5] * self.g_res3)
            dx5 = self.k_int * (x[4] * self.a[4])
            self.x += np.array([dx0, dx1, dx2, dx3, dx4, dx5]) * self.dt
        y_sum = np.dot(self.x, self.c) - v_applied * self.g_eld
        q_out = 1.0 if y_sum >= 0 else -1.0
        self.delay_reg = q_out 
        return q_out

    def calc_ntf_response(self, freqs):
        """è®¡ç®—ç†è®º NTF æ›²çº¿ç”¨äºç»˜å›¾"""
        s = 1j * 2 * np.pi * freqs
        k = self.k_int
        A = np.zeros((6, 6))
        A[0, 1] = -k * self.g_res1; A[1, 0] = k * self.a[0]
        A[2, 1] = k * self.a[1];    A[2, 3] = -k * self.g_res2
        A[3, 2] = k * self.a[2]
        A[4, 3] = k * self.a[3];    A[4, 5] = -k * self.g_res3
        A[5, 4] = k * self.a[4]
        B_dac = np.zeros((6, 1)); B_dac[0] = -k * self.g_dac
        C = np.array(self.c).reshape(1, 6)
        I = np.eye(6)
        ntf_mag_db = []
        for f_val in freqs:
            try:
                resolvent = np.linalg.inv(1j * 2 * np.pi * f_val * I - A)
                L_total = (C @ resolvent @ B_dac)[0,0] - self.g_eld
                ntf_mag_db.append(20 * np.log10(np.abs(1 / (1 + L_total))))
            except:
                ntf_mag_db.append(0)
        return np.array(ntf_mag_db)

def generate_custom_protocol(t, fs, carrier_freq, amp_high, amp_low, chip_period):
    """
    ç”Ÿæˆè‡ªå®šä¹‰åè®®æ³¢å½¢ (Load Modulation Logic)
    é€»è¾‘åè½¬: 1 -> AmpLow, 0 -> AmpHigh
    """
    # 1. å®šä¹‰ Chip åºåˆ— (1=ModulationOn=Low, 0=ModulationOff=High)
    
    # [æ–°å¢] Preamble: 0101 äº¤æ›¿ (8 chips)
    # ç‰©ç†æ„ä¹‰: High-Low-High-Low... ç”¨äºäº§ç”Ÿäº¤æµåˆ†é‡å”¤é†’ HPF
    seq_preamble = np.array([0, 1, 0, 1, 0, 1, 0, 1])
    
    # EQ (è¿ä¾‹ç ): 11ä¸ª1ï¼Œ1ä¸ª0
    # ç‰©ç†æ„ä¹‰: 11ä¸ª Low (é•¿ä½ç”µå¹³), 1ä¸ª High
    seq_eq = np.array([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0]) 
    
    # Data 1: 11110000 -> Low*4, High*4
    seq_data_1 = np.array([1, 1, 1, 1, 0, 0, 0, 0])        
    
    # Data 0: 00001111 -> High*4, Low*4
    seq_data_0 = np.array([0, 0, 0, 0, 1, 1, 1, 1])        
    
    # 2. æ„é€ å®Œæ•´çš„ Chip åˆ—è¡¨
    total_time = t[-1]
    idle_time = 0.002 # 2ms é™é»˜
    
    # è®¡ç®— Payload èƒ½æ”¾å¤šå°‘ bit
    remaining_time = total_time - idle_time - ((len(seq_preamble) + len(seq_eq)) * chip_period)
    num_bits = int(remaining_time / (8 * chip_period))
    
    print(f"ğŸ“¦ åè®®æ„é€ : 1 Chip = {chip_period*1e6:.1f}us")
    print(f"   Structure: [Preamble 8] + [EQ {len(seq_eq)}] + [Payload {num_bits} bits]")
    
    np.random.seed(42)
    random_bits = np.random.randint(0, 2, num_bits)
    
    # æ‹¼æ¥åºåˆ—
    full_chip_sequence = []
    full_chip_sequence.extend(seq_preamble) # [æ–°å¢]
    full_chip_sequence.extend(seq_eq)       # Header
    for b in random_bits:                   # Body
        if b == 1: full_chip_sequence.extend(seq_data_1)
        else:      full_chip_sequence.extend(seq_data_0)
        
    full_chip_sequence = np.array(full_chip_sequence)
    
    # 3. æ˜ å°„åˆ°æ—¶é—´è½´ (Upsampling)
    # é»˜è®¤å…¨é«˜ (IdleçŠ¶æ€ = æ— è´Ÿè½½ = AmpHigh)
    envelope = np.ones(len(t)) * amp_high
    
    idle_samples = int(idle_time * fs)
    samples_per_chip = int(chip_period * fs)
    
    current_idx = idle_samples
    for chip_val in full_chip_sequence:
        end_idx = current_idx + samples_per_chip
        if end_idx > len(t): break
        
        # [å…³é”®ä¿®æ”¹] é€»è¾‘åè½¬æ˜ å°„
        # chip_val=1 (Modulation On) -> AmpLow
        # chip_val=0 (Modulation Off) -> AmpHigh
        val = amp_low if chip_val == 1 else amp_high
        
        envelope[current_idx : end_idx] = val
        current_idx = end_idx
        
    # 4. è½½æ³¢è°ƒåˆ¶
    carrier = np.sin(2 * np.pi * carrier_freq * t)
    return carrier * envelope

def main():
    # 1. è®¡ç®—è°ƒè°ç³»æ•° (å°†é™·æ³¢ç‚¹ç§»åˆ° 125k)
    target_f = 125000; current_f = 60500 
    scale_factor = (target_f / current_f) ** 2
    print(f"ğŸ”§ SDM ç³»æ•°ä¿®æ­£: g_res ç¼©æ”¾ {scale_factor:.4f} å€")
    
    # 2. è®¡ç®—å¹…åº¦å‚æ•°
    amp_h = CONFIG['base_amp']
    amp_l = CONFIG['base_amp'] * (1 - CONFIG['mod_depth'])
    print(f"âš¡ ä¿¡å·å¹…åº¦: High={amp_h}, Low={amp_l} (Depth={CONFIG['mod_depth']:.5f})")
    
    # 3. ç”Ÿæˆä¿¡å·
    N = int(CONFIG['duration'] * CONFIG['fs'])
    t = np.arange(N) / CONFIG['fs']
    
    sig = generate_custom_protocol(
        t, CONFIG['fs'], CONFIG['carrier_freq'],
        amp_h, amp_l, CONFIG['chip_period']
    )
    
    # åŠ ä¸€ç‚¹å™ªå£° (å¯é€‰)
    noise_p = np.mean(sig**2) / (10**(CONFIG['snr_db']/10))
    sig_noisy = sig + np.random.normal(0, np.sqrt(noise_p), N)
    
    # 4. è¿è¡Œ SDM
    print("ğŸš€ è¿è¡Œ SDM ä»¿çœŸ (Load Modulation Logic)...")
    sdm = CTSDM_Model(fs=CONFIG['fs'], g_res_scale=scale_factor)
    pdm = np.zeros(N)
    for i in range(N):
        pdm[i] = 1 if sdm.step(sig_noisy[i]) > 0 else -1

    # 5. ä¿å­˜æ•°æ®
    np.savetxt(CONFIG['out_pdm'], pdm, fmt='%d')
    np.savetxt(CONFIG['out_ref'], sig, fmt='%.8f')
    print(f"ğŸ’¾ æ•°æ®å·²ä¿å­˜è‡³ data/ ç›®å½•")

    # ================= 6. é¢‘è°±åˆ†æä¸ç»˜å›¾ =================
    print("ğŸ“Š æ­£åœ¨ç”Ÿæˆé¢‘è°±åˆ†æå›¾...")
    freqs, psd = signal.welch(pdm, CONFIG['fs'], nperseg=32768, scaling='density')
    psd_db = 10 * np.log10(psd + 1e-20)
    
    # SINAD è®¡ç®—
    mask_signal = (freqs >= CONFIG['signal_bw'][0]) & (freqs <= CONFIG['signal_bw'][1])
    mask_total = (freqs >= CONFIG['total_bw'][0]) & (freqs <= CONFIG['total_bw'][1])
    p_signal = np.sum(psd[mask_signal])
    p_noise = np.sum(psd[mask_total]) - p_signal
    sinad = 10 * np.log10(p_signal / p_noise) if p_noise > 0 else 0
    print(f"   -> æœ€ç»ˆ SINAD: {sinad:.2f} dB")

    # è®¡ç®—ç†è®º NTF
    f_ntf = np.linspace(CONFIG['view_bw'][0], CONFIG['view_bw'][1], 1000)
    ntf_db = sdm.calc_ntf_response(f_ntf)

    # ç»˜å›¾
    plt.style.use('seaborn-v0_8-paper')
    fig, ax1 = plt.subplots(figsize=(10, 6), dpi=150)
    
    # ç»˜åˆ¶ PSD
    ax1.plot(freqs/1000, psd_db, '#1f77b4', lw=0.8, alpha=0.8, label='Simulated PSD')
    ax1.set_ylabel('PSD (dB/Hz)', color='#1f77b4', fontweight='bold')
    ax1.tick_params(axis='y', labelcolor='#1f77b4')
    ax1.set_xlabel('Frequency (kHz)')
    ax1.set_xlim(0, 250)
    ax1.set_ylim(-160, 10)
    
    # æ ‡æ³¨åŒºåŸŸ
    ax1.axvspan(120, 130, color='green', alpha=0.1, label='Signal BW')
    ax1.axvspan(110, 140, color='gray', alpha=0.1, label='Total BW')
    
    # ç»˜åˆ¶ NTF (åŒè½´)
    ax2 = ax1.twinx()
    ax2.plot(f_ntf/1000, ntf_db, '#d62728', ls='--', lw=1.5, label='Theoretical NTF')
    ax2.set_ylabel('NTF Gain (dB)', color='#d62728', fontweight='bold')
    ax2.tick_params(axis='y', labelcolor='#d62728')
    ax2.set_ylim(-140, 20)
    
    # æ ‡æ³¨é™·æ³¢ç‚¹
    notch_idx = signal.argrelextrema(ntf_db, np.less)[0]
    for nf in f_ntf[notch_idx]:
        ax2.axvline(x=nf/1000, color='#d62728', linestyle=':', alpha=0.4)
    
    plt.title(f"SDM Analysis (ModDepth={CONFIG['mod_depth']:.5f})\nSINAD: {sinad:.2f} dB")
    
    # åˆå¹¶å›¾ä¾‹
    lines1, labels1 = ax1.get_legend_handles_labels()
    lines2, labels2 = ax2.get_legend_handles_labels()
    ax1.legend(lines1 + lines2, labels1 + labels2, loc='upper left')
    
    plt.tight_layout()
    plt.savefig(CONFIG['plot_file'])
    print(f"ğŸ’¾ é¢‘è°±å›¾å·²ä¿å­˜: {CONFIG['plot_file']}")

if __name__ == "__main__":
    main()
